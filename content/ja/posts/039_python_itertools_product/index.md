+++
date = '2026-02-06T22:51:39+09:00'
draft = false
title = 'itertools.productの実践'
categories = ["python"]
+++

# Pythonで組み合わせパターンを生成

## 問題：隣接キーからの組み合わせ生成

テンキーパッドで数字を入力する際、観察された数字から
隣接するキーを含めた全ての可能性を列挙したい場合を考えます。

例：観察された入力が「1」の場合
- テンキー上で「1」に隣接するのは「1,2,4」
- 可能性のある入力：['1', '2', '4']

例：観察された入力が「21」の場合
- 「2」の隣接キー：(1,2,3,5)
- 「1」の隣接キー：(1,2,4)
- 全ての組み合わせ：['11','21','31','51','12','22',...] （12通り）

このような「各位置の選択肢から全組み合わせを作る」処理は
itertools.productを使うと簡潔に実装できます。

## itertools.productとは

公式ドキュメント：https://docs.python.org/ja/3.13/library/itertools.html

itertools.productは「デカルト積」を計算します。
難しく聞こえますが、要は **「複数のリストから1つずつ取り出した全組み合わせ」** です。

### 簡単な例
```python
from itertools import product

# 2つのリストの全組み合わせ
list(product(['A', 'B'], ['1', '2']))
# [('A', '1'), ('A', '2'), ('B', '1'), ('B', '2')]

# 3つのリストの全組み合わせ
list(product(['X', 'Y'], ['1', '2'], ['α', 'β']))
# [('X', '1', 'α'), ('X', '1', 'β'), ('X', '2', 'α'), ...]
```

###  **Observed PIN サンプルコード**
```python
from itertools import product

def get_pins(observed):
    # 各数字とその隣接キーの対応表
    lock = {
        '1': ('1', '2', '4'),
        '2': ('1', '2', '3', '5'),
        '3': ('2', '3', '6'),
        '4': ('1', '4', '5', '7'),
        '5': ('2', '4', '5', '6', '8'),
        '6': ('3', '5', '6', '9'),
        '7': ('4', '7', '8'),
        '8': ('5', '7', '8', '9', '0'),
        '9': ('6', '8', '9'),
        '0': ('8', '0')
    }

    # 観察された各桁について、可能な数字のリストを作成
    # 例: '21' → [('1','2','3','5'), ('1','2','4')]
    possible_digits = [lock[digit] for digit in observed]

    # product で全組み合わせを生成し、文字列に結合
    # *possible_digits でリストを展開して渡す
    combinations = [''.join(combo) for combo in product(*possible_digits)]

    return combinations

# テスト
print(get_pins('1'))
# ['1', '2', '4']

print(get_pins('21'))
# ['11', '21', '31', '51', '12', '22', '32', '52', '13', '23', '33', '53', '14', '24', '34', '54']
# 4 × 3 = 12通り
```

## itertools.product vs 再帰：どちらを使う?

| 観点 | itertools.product | 再帰版 |
|------|-------------------|--------|
| コード量 | 短い（3行程度） | やや長い |
| 可読性 | 意図が明確 | ロジックの理解が必要 |
| 実務での推奨度 | ⭐⭐⭐ 推奨 | 学習目的なら⭕ |
| ライブラリ依存 | itertools（標準） | なし |

**結論：実務ではitertools.productを使うべき**
- 標準ライブラリなので追加インストール不要
- コードが短く、バグが入りにくい
- 「車輪の再発明」を避ける良い例

## 参考：再帰による実装（学習用）

アルゴリズムの理解を深めるため、再帰でも実装してみます。

**考え方：**
1. 最初の1桁の可能性それぞれについて
2. 残りの桁の組み合わせを再帰的に取得
3. 結合して返す
```python
def get_pins(observed):
    lock = {
        '1': ('1', '2', '4'),
        '2': ('1', '2', '3', '5'),
        # ... (省略)
    }

    # 基底条件：observedが空なら、空文字列のリストを返す
    if not observed:
        return ['']

    # 最初の桁と残りに分割
    first_digit = observed[0]
    rest = observed[1:]

    result = []
    # 最初の桁の各可能性について
    for char in lock[first_digit]:
        # 残りの桁の組み合わせを再帰的に取得
        for combination in get_pins(rest):
            result.append(char + combination)

    return result
```

**動作イメージ（'21'の場合）:**
```
get_pins('21')
├─ first='2', rest='1'
│  ├─ char='1': get_pins('1') → ['1','2','4'] → ['11','12','14']
│  ├─ char='2': get_pins('1') → ['1','2','4'] → ['21','22','24']
│  ├─ char='3': get_pins('1') → ['1','2','4'] → ['31','32','34']
│  └─ char='5': get_pins('1') → ['1','2','4'] → ['51','52','54']
```

## 学習のポイント

### itertools で最低限覚えておくべき3つ
1. **product**: 全組み合わせ（直積）← 今回
2. **combinations**: 順序なし組み合わせ（例：ABCから2つ選ぶ→AB,AC,BC）
3. **permutations**: 順列（例：ABCの並べ替え→ABC,ACB,BAC,...）

### 実務での使い所
- 入力候補の生成
- テストケースの網羅
- あいまい検索の実装
- パスワード候補の列挙（セキュリティ分析）